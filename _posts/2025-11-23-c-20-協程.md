---
layout: post
title: C++20 å”ç¨‹
date: 2025-11-23 22:36 +0800
tags:
  - cpp
  - cpp20
  - coroutine
---

## Overview

### æ­·å²èƒŒæ™¯

- Melvin Conway æ–¼ 1963 å¹´åœ¨ç·¨è­¯å™¨å»ºæ§‹çš„æ›¸ç±ä¸­ä¸­é¦–å‰µæ­¤è¡“èª
- Donald Knuth èªç‚ºç¨‹åºï¼ˆproceduresï¼‰æ˜¯å”ç¨‹ï¼ˆcoroutinesï¼‰çš„ç‰¹ä¾‹
- å› æ­¤å”ç¨‹æ¦‚å¿µå¾ˆæ—©å°±å­˜åœ¨ï¼Œä½†åœ¨ C++20 æ‰æ­£å¼å¼•å…¥
- å‡½æ•¸ vs å”ç¨‹
  - å‡½æ•¸åªèƒ½å‘¼å«ï¼ˆcallï¼‰å’Œè¿”å›ï¼ˆreturnï¼‰
  - å”ç¨‹å¯ä»¥å‘¼å«ï¼ˆcallï¼‰ã€æš«åœï¼ˆsuspendï¼‰ã€æ¢å¾©ï¼ˆresumeï¼‰ã€éŠ·æ¯€ï¼ˆdestroyï¼‰

### C++20 ä¸­çš„å”ç¨‹é—œéµå­—

- é—œéµå­— `co_await`
  - æš«åœå’Œæ¢å¾©è¡¨é”å¼çš„åŸ·è¡Œ
  - éé˜»å¡ï¼šå¯¦ç¾è³‡æºå‹å¥½çš„ç­‰å¾…ï¼ˆresource-friendly waitingï¼‰ï¼Œè€Œéæ¶ˆè€—è³‡æºçš„é˜»å¡ï¼ˆresource-consuming blockingï¼‰
  - ç¯„ä¾‹ï¼š`auto result = func()` åœ¨çµæœæœªå°±ç·’æ™‚ä¸æœƒé˜»å¡
- é—œéµå­— `co_yield`
  - å¯¦ç¾ç”Ÿæˆå™¨å‡½æ•¸ï¼ˆgenerator functionsï¼‰
  - æ¯æ¬¡å‘¼å«è¿”å›æ–°å€¼
  - å‰µå»ºè³‡æ–™æµï¼ˆå¯ä»¥æ˜¯ç„¡é™çš„ï¼‰
  - å¯¦ç¾æƒ°æ€§æ±‚å€¼ï¼ˆlazy evaluationï¼‰

![coroutine](assets/img/Coroutine.png)

### ç”Ÿæˆå™¨ç¯„ä¾‹æ¯”è¼ƒ

- å‚³çµ±å‡½æ•¸ï¼ˆç›´æ¥æ±‚å€¼ï¼‰

  ```cpp
  std::vector<int> getNumbers(int begin, int end, int inc = 1) {
    std::vector<int> numbers;
    for (int i = begin; i < end; i += inc) {
      numbers.push_back(i);
    }
    return numbers;
  }
  ```

- å”ç¨‹ç”Ÿæˆå™¨ï¼ˆæƒ°æ€§æ±‚å€¼ï¼‰

  ```cpp
  generator<int> generatorForNumbers(int begin, int inc = 1) {
    for (int i = begin;; i += inc) {
      co_yield i;
    }
  }
  ```

  - æŒ‰éœ€ç”Ÿæˆå€¼
  - å¯å®‰å…¨å‰µå»ºç„¡é™è³‡æ–™æµ
  - æ¯æ¬¡ `co_yield` å¾Œæš«åœ
  - å¾æš«åœè™•ç²¾ç¢ºæ¢å¾©åŸ·è¡Œ

## Characteristics

### å…¸å‹æ‡‰ç”¨å ´æ™¯

- äº‹ä»¶é©…å‹•æ‡‰ç”¨ç¨‹å¼ï¼šæ¨¡æ“¬ã€éŠæˆ²ã€ä¼ºæœå™¨ã€ä½¿ç”¨è€…ä»‹é¢ã€æ¼”ç®—æ³•
- å”ä½œå¼å¤šå·¥ï¼ˆcooperative multitaskingï¼‰
  - æ¯å€‹ä»»å‹™ä½”ç”¨æ‰€éœ€æ™‚é–“ï¼Œä½†é¿å…ç¡çœ æˆ–ç­‰å¾…
  - ä¸»å‹•è®“å‡ºåŸ·è¡Œæ¬Šçµ¦å…¶ä»–ä»»å‹™
  - å°æ¯”ï¼šæ¶ä½”å¼å¤šå·¥ï¼ˆpreemptive multitaskingï¼‰ç”±æ’ç¨‹å™¨æ±ºå®š CPU æ™‚é–“åˆ†é…

### åº•å±¤æ¦‚å¿µ

C++20 å”ç¨‹çš„ä¸‰å¤§ç‰¹æ€§ï¼š

- **éå°ç¨±ï¼ˆAsymmetricï¼‰**
  - å·¥ä½œæµç¨‹è¿”å›å‘¼å«è€…ï¼Œæœ‰æ˜ç¢ºçš„å‘¼å«è€…å’Œè¢«å‘¼å«è€…é–“çš„å±¤ç´šé—œä¿‚
  - å°ç¨±å”ç¨‹å‰‡å¯å°‡å·¥ä½œæµç¨‹å§”æ´¾çµ¦å…¶ä»–å”ç¨‹ï¼Œå¦‚ Lua coroutine å’Œ Ruby Fiber
- **ç¬¬ä¸€é¡å‡½æ•¸ï¼ˆFirst-class functionï¼‰**
  - å”ç¨‹å¦‚åŒè³‡æ–™ï¼Œå¯ä½œç‚ºå‡½æ•¸åƒæ•¸ã€è¿”å›å€¼æˆ–å„²å­˜åœ¨è®Šæ•¸ä¸­
  - ç¬¬ä¸€é¡å‡½æ•¸æ˜¯æŒ‡å‡½æ•¸å¯ä»¥ï¼š
    - è¢«è³¦å€¼çµ¦è®Šæ•¸
    - ä½œç‚ºåƒæ•¸å‚³éçµ¦å…¶ä»–å‡½æ•¸
    - ä½œç‚ºå‡½æ•¸çš„è¿”å›å€¼
    - åœ¨é‹è¡Œæ™‚å‹•æ…‹å‰µå»º
- **ç„¡å †ç–Šï¼ˆStacklessï¼‰**
  - èƒ½æš«åœå’Œæ¢å¾©é ‚å±¤å”ç¨‹
  - ä½¿ç”¨å‘¼å«è€…çš„å †ç–Š
  - åˆç¨±å¯æ¢å¾©å‡½æ•¸ï¼ˆresumable functionsï¼‰

### è¨­è¨ˆç›®æ¨™

ææ¡ˆ [N4402](https://isocpp.org/files/papers/N4402.pdf)

- é«˜åº¦å¯æ“´å±•æ€§ï¼ˆæ”¯æ´æ•¸åå„„å€‹ä¸¦ç™¼å”ç¨‹ï¼‰
- é«˜æ•ˆçš„æ¢å¾©èˆ‡æš«åœæ“ä½œï¼ˆæˆæœ¬æ¥è¿‘å‡½æ•¸å‘¼å«é–‹éŠ·ï¼‰
- èˆ‡ç¾æœ‰è¨­æ–½ç„¡ç¸«äº’å‹•ä¸”ç„¡é¡å¤–é–‹éŠ·
- é–‹æ”¾å¼å”ç¨‹æ©Ÿåˆ¶ï¼Œè®“å‡½å¼åº«è¨­è¨ˆè€…é–‹ç™¼å„ç¨®é«˜éšèªç¾©ï¼ˆç”Ÿæˆå™¨ã€goroutinesã€ä»»å‹™ç­‰ï¼‰
- å¯ç”¨æ–¼ç¦æ­¢æˆ–ä¸æ”¯æ´ä¾‹å¤–çš„ç’°å¢ƒ

> ğŸ’¡ **ç‚ºä½•é¸æ“‡ç„¡å †ç–Šè¨­è¨ˆï¼Ÿ**
> åŸºæ–¼å¯æ“´å±•æ€§å’Œç„¡ç¸«äº’å‹•çš„è¨­è¨ˆç›®æ¨™ã€‚æœ‰å †ç–Šå”ç¨‹ï¼ˆå¦‚ Boost.Fiberï¼‰é¡ä¼¼åŸ·è¡Œç·’ï¼Œåœ¨ Windows ä¸Šé è¨­ä¿ç•™ 1MB å †ç–Šï¼ŒLinux ä¸Šç‚º 2MBï¼Œé›£ä»¥æ”¯æ´å¤§é‡ä¸¦ç™¼ã€‚

### æˆç‚ºå”ç¨‹çš„æ¢ä»¶

å‡½æ•¸ä½¿ç”¨ä»¥ä¸‹ä»»ä¸€é—œéµå­—å³æˆç‚ºå”ç¨‹ï¼š

- `co_return`
- `co_await`
- `co_yield`
- ç¯„åœ for è¿´åœˆä¸­çš„ `co_await` è¡¨é”å¼

### å”ç¨‹å·¥å»  vs å”ç¨‹ç‰©ä»¶

âš ï¸ é‡è¦å€åˆ†ï¼š

```cpp
MyFuture<int> createFuture() { co_return 2021; }

int main() {
  auto fut = createFuture();
  std::cout << "fut.get(): " << fut.get() << '\n';
}
```

- **å”ç¨‹å·¥å» ï¼ˆCoroutine Factoryï¼‰**ï¼šå‡½æ•¸ `createFuture`
- **å”ç¨‹ç‰©ä»¶ï¼ˆCoroutine Objectï¼‰**ï¼šè¿”å›çš„ `MyFuture<int>` å‹åˆ¥ç‰©ä»¶
  - å¯æ¢å¾©çš„ç‰©ä»¶
  - å¯¦ä½œæ¡†æ¶ä»¥å»ºæ¨¡ç‰¹å®šè¡Œç‚º

### é™åˆ¶

å”ç¨‹**ä¸èƒ½**ï¼š

- ä½¿ç”¨ `return` èªå¥
- ä½¿ç”¨ä½”ä½è¿”å›å‹åˆ¥ï¼ˆ`auto` æˆ– conceptsï¼‰
- æ˜¯å¯è®Šåƒæ•¸ï¼ˆvariadic argumentsï¼‰å‡½æ•¸
- æ˜¯ `constexpr` å‡½æ•¸
- æ˜¯å»ºæ§‹å‡½æ•¸æˆ–è§£æ§‹å‡½æ•¸
- æ˜¯ `main` å‡½æ•¸

## The Framework

### æ¡†æ¶çµ„æˆ

- å¯¦ä½œå”ç¨‹çš„æ¡†æ¶åŒ…å«è¶…é 20 å€‹å‡½æ•¸
  - éƒ¨åˆ†å¿…é ˆå¯¦ä½œ
  - éƒ¨åˆ†å¯é¸æ“‡æ€§è¦†å¯«
  - å¯æ ¹æ“šéœ€æ±‚å®¢è£½åŒ–å”ç¨‹è¡Œç‚º

### å”ç¨‹çš„ä¸‰å¤§çµ„æˆéƒ¨åˆ†

#### Promise ç‰©ä»¶ï¼ˆPromise Objectï¼‰ï¼šåœ¨å”ç¨‹å…§éƒ¨æ“ä½œï¼Œå‚³éçµæœæˆ–ä¾‹å¤–

**å¿…é ˆæ”¯æ´çš„ä»‹é¢ï¼š**

| æˆå“¡å‡½æ•¸                | èªªæ˜                       |
| ----------------------- | -------------------------- |
| Default constructor     | Promise å¿…é ˆå¯é è¨­å»ºæ§‹     |
| `initial_suspend()`     | æ±ºå®šå”ç¨‹åŸ·è¡Œå‰æ˜¯å¦æš«åœ     |
| `final_suspend()`       | æ±ºå®šå”ç¨‹çµæŸå‰æ˜¯å¦æš«åœ     |
| `unhandled_exception()` | ä¾‹å¤–ç™¼ç”Ÿæ™‚è¢«å‘¼å«           |
| `get_return_object()`   | è¿”å›å”ç¨‹ç‰©ä»¶ï¼ˆå¯æ¢å¾©ç‰©ä»¶ï¼‰ |
| `return_value(val)`     | ç”± `co_return val` å‘¼å«    |
| `return_void()`         | ç”± `co_return` å‘¼å«        |
| `yield_value(val)`      | ç”± `co_yield val` å‘¼å«     |

**é—œéµç‰¹æ€§ï¼š**

- ç·¨è­¯å™¨è‡ªå‹•åœ¨å”ç¨‹åŸ·è¡ŒæœŸé–“å‘¼å«é€™äº›å‡½æ•¸
- `get_return_object()` è¿”å›å®¢æˆ¶ç«¯ç”¨ä¾†èˆ‡å”ç¨‹äº’å‹•çš„å¯æ¢å¾©ç‰©ä»¶
- Promise è‡³å°‘éœ€è¦ `return_value`ã€`return_void` æˆ– `yield_value` å…¶ä¸­ä¹‹ä¸€
  - `return_value` å’Œ `return_void` åªèƒ½æ“‡ä¸€å¯¦ä½œ
  - è‹¥å”ç¨‹æ°¸ä¸çµæŸï¼Œå‰‡ä¸éœ€å®šç¾© `return_value` æˆ– `return_void`
  - `return_value` å’Œ `yield_value` éƒ½èƒ½é€²è¡Œé‡è¼‰ä»¥æ”¯æ´å¤šç¨®å‹åˆ¥
- `yield_value`ã€`initial_suspend`ã€`final_suspend` è¿”å› **awaitable**
  - Awaitable æ˜¯å¯ç­‰å¾…çš„ç‰©ä»¶
  - æ±ºå®šå”ç¨‹æ˜¯å¦æš«åœ

#### å”ç¨‹æ§åˆ¶æŸ„ï¼ˆCoroutine Handleï¼‰ï¼šå®¢æˆ¶ç«¯ç²å–æ­¤æ§åˆ¶æŸ„èˆ‡ promise ç‰©ä»¶äº’å‹•

- æ˜¯éæ“æœ‰å‹æ§åˆ¶æŸ„ï¼ˆNon-owning Handleï¼‰
- å¾å¤–éƒ¨æ¢å¾©æˆ–éŠ·æ¯€å”ç¨‹å¹€
- æ˜¯å¯æ¢å¾©å‡½æ•¸çš„ä¸€éƒ¨åˆ†

#### Handle çš„å…©ç¨®å½¢å¼

**`std::coroutine_handle<promise_type>`ï¼ˆå‹åˆ¥åŒ–æ§åˆ¶æŸ„ï¼‰**

- å¯å­˜å–ç‰¹å®š promise ç‰©ä»¶ï¼š`handle.promise()`
- å¯é€²è¡Œå”ç¨‹æ§åˆ¶ï¼š`resume()`, `done()`, `destroy()`
- ç”¨æ–¼éœ€è¦è®€å–æˆ–ä¿®æ”¹ promise ç‹€æ…‹çš„å ´æ™¯

**`std::coroutine_handle<>`ï¼ˆå‹åˆ¥æ“¦é™¤æ§åˆ¶æŸ„ï¼Œç­‰åŒæ–¼ `std::coroutine_handle<void>`ï¼‰**

- åƒ…èƒ½é€²è¡Œå”ç¨‹æ§åˆ¶ï¼š`resume()`, `done()`, `destroy()`
- **ç„¡æ³•**å­˜å– promise ç‰©ä»¶
- ç”¨æ–¼æ³›å‹å”ç¨‹æ§åˆ¶ï¼Œä¸é—œå¿ƒ promise çš„å…·é«”å‹åˆ¥

ğŸ’¡ **ç‚ºä½• `await_suspend` ä½¿ç”¨å‹åˆ¥æ“¦é™¤ç‰ˆæœ¬ï¼Ÿ**

```cpp
// Awaiter ä»‹é¢
void await_suspend(std::coroutine_handle<> handle); // å‹åˆ¥æ“¦é™¤ï¼Œå¯æ¥å—ä»»ä½•å”ç¨‹
```

å› ç‚º Awaiter é€šå¸¸åªéœ€è¦æ¢å¾©å‘¼å«æ–¹å”ç¨‹ï¼Œä¸éœ€è¦å­˜å–å…¶ promise å…§å®¹ï¼Œä½¿ç”¨ `<>` æä¾›æœ€å¤§å½ˆæ€§ã€‚

ğŸ’¡ **è½‰æ›è¦å‰‡ï¼š**

- å‹åˆ¥åŒ– â†’ å‹åˆ¥æ“¦é™¤ï¼šâœ… è‡ªå‹•è½‰æ›
- å‹åˆ¥æ“¦é™¤ â†’ å‹åˆ¥åŒ–ï¼šâŒ ä¸å®‰å…¨ï¼Œéœ€è¦ä¿è­‰å‹åˆ¥æ­£ç¢ºæ€§

**Generator ç¯„ä¾‹ï¼š**

```cpp
#include <coroutine>
#include <iostream>

template <typename T> struct Generator {
  struct promise_type {
    T current_value;

    Generator get_return_object() {
      return Generator{
          std::coroutine_handle<promise_type>::from_promise(*this)};
    }
    std::suspend_always initial_suspend() { return {}; }
    std::suspend_always final_suspend() noexcept { return {}; }
    void unhandled_exception() {}

    std::suspend_always yield_value(T value) {
      current_value = value;
      return {};
    }
  };

  using handle_type = std::coroutine_handle<promise_type>;

  Generator(handle_type h) : coro(h) {}
  handle_type coro;

  ~Generator() {
    if (coro) {
      coro.destroy();
    }
  }

  T getValue() { return coro.promise().current_value; }

  bool next() {
    coro.resume();
    return not coro.done();
  }
};

Generator<int> fac() { co_yield 42; }

int main() {
  auto g = fac();
  g.next();
  auto res = g.getValue();
  std::cout << res << "\n";
}
```

**å”ç¨‹æ§åˆ¶æŸ„æä¾›çš„æ“ä½œï¼š**

- **æ¢å¾©å”ç¨‹**ï¼š`coro.resume()` æˆ– `coro()`
- **éŠ·æ¯€å”ç¨‹**ï¼š`coro.destroy()`
- **æª¢æŸ¥ç‹€æ…‹**ï¼š`coro`ï¼ˆåƒ…åœ¨æœ€çµ‚æš«åœé»è¿”å› trueï¼‰

**è‡ªå‹•éŠ·æ¯€ï¼š**

- å”ç¨‹åœ¨å‡½æ•¸æœ¬é«”çµæŸæ™‚è‡ªå‹•éŠ·æ¯€

> âš ï¸ **å¯æ¢å¾©ç‰©ä»¶éœ€è¦å…§éƒ¨å‹åˆ¥ `promise_type`**
>
> - æ–¹æ³•ä¸€ï¼šåœ¨å¯æ¢å¾©ç‰©ä»¶ï¼ˆå¦‚ Generatorï¼‰ä¸­å®šç¾©å…§éƒ¨å‹åˆ¥ `promise_type`
> - æ–¹æ³•äºŒï¼šç‰¹åŒ– `std::coroutine_traits<Generator>` ä¸¦åœ¨å…¶ä¸­å®šç¾©å…¬é–‹æˆå“¡ `promise_type`

#### å”ç¨‹å¹€ï¼ˆCoroutine Frameï¼‰ï¼špromise ç‰©ä»¶åœ¨æ­¤ä¿å­˜ç‹€æ…‹

- **å…§éƒ¨ç‹€æ…‹çµæ§‹**ï¼ˆé€šå¸¸åˆ†é…åœ¨å †ç©ä¸Šï¼‰
  - Promise ç‰©ä»¶
  - å”ç¨‹çš„è¤‡è£½åƒæ•¸
  - æš«åœé»çš„è¡¨ç¤º
  - æœ¬åœ°è®Šæ•¸
    - ç”Ÿå‘½é€±æœŸåœ¨ç•¶å‰æš«åœé»å‰çµæŸçš„è®Šæ•¸
    - ç”Ÿå‘½é€±æœŸè¶…éç•¶å‰æš«åœé»çš„è®Šæ•¸

**å„ªåŒ–é…ç½®çš„æ¢ä»¶ï¼š**

è¦é¿å…å †ç©åˆ†é…ï¼Œéœ€æ»¿è¶³å…©å€‹æ¢ä»¶ï¼š

1. å”ç¨‹çš„ç”Ÿå‘½é€±æœŸåµŒå¥—åœ¨å‘¼å«è€…çš„ç”Ÿå‘½é€±æœŸå…§
2. å‘¼å«è€…çŸ¥é“å”ç¨‹å¹€çš„å¤§å°

**é—œéµæŠ½è±¡**ï¼šå”ç¨‹æ¡†æ¶çš„æ ¸å¿ƒæŠ½è±¡æ˜¯ **awaitables** å’Œ **awaiters**

## Awaitable and Awaiters

### æ ¸å¿ƒæ¦‚å¿µ

Promise ç‰©ä»¶çš„ä¸‰å€‹å‡½æ•¸æœƒè¿”å› awaitablesï¼š

- `yield_value`
- `initial_suspend`
- `final_suspend`

### Awaitables

**å®šç¾©ï¼š**

- **Awaitable** æ˜¯å¯ä»¥ç­‰å¾…çš„ç‰©ä»¶
- æ±ºå®šå”ç¨‹æ˜¯å¦æš«åœ

**ç·¨è­¯å™¨è‡ªå‹•ç”Ÿæˆçš„å‘¼å«ï¼š**

| åŸå§‹å‘¼å«                 | ç·¨è­¯å™¨ç”Ÿæˆçš„å‘¼å«                   |
| ------------------------ | ---------------------------------- |
| `yield value`            | `co_await prom.yield_value(value)` |
| `prom.initial_suspend()` | `co_await prom.initial_suspend()`  |
| `prom.final_suspend()`   | `co_await prom.final_suspend()`    |

- `co_await` é‹ç®—å­éœ€è¦ awaitable ä½œç‚ºåƒæ•¸
- Awaitables å¿…é ˆå¯¦ä½œ `Awaitable` æ¦‚å¿µ

#### Awaitable æ¦‚å¿µ

**å¿…é ˆå¯¦ä½œçš„ä¸‰å€‹å‡½æ•¸ï¼š**

| å‡½æ•¸            | èªªæ˜                                                    |
| --------------- | ------------------------------------------------------- |
| `await_ready`   | æŒ‡ç¤ºçµæœæ˜¯å¦å°±ç·’ã€‚è¿”å› `false` æ™‚æœƒå‘¼å« `await_suspend` |
| `await_suspend` | æ’ç¨‹å”ç¨‹ä»¥ä¾¿æ¢å¾©æˆ–éŠ·æ¯€                                  |
| `await_resume`  | ç‚º `co_await exp` è¡¨é”å¼æä¾›çµæœ                        |

#### æ¨™æº– Awaitables

C++20 æ¨™æº–å®šç¾©äº†å…©å€‹åŸºæœ¬ awaitablesï¼š

**`std::suspend_always`** - ç¸½æ˜¯æš«åœ

```cpp
struct suspend_always {
  constexpr bool await_ready() const noexcept { return false; }
  constexpr void await_suspend(std::coroutine_handle<>) const noexcept {}
  constexpr void await_resume() const noexcept {}
};
```

- `await_ready()` è¿”å› `false`ï¼Œå› æ­¤ç¸½æ˜¯æš«åœ

**`std::suspend_never`** - æ°¸ä¸æš«åœ

```cpp
struct suspend_never {
  constexpr bool await_ready() const noexcept { return true; }
  constexpr void await_suspend(std::coroutine_handle<>) const noexcept {}
  constexpr void await_resume() const noexcept {}
};
```

- `await_ready()` è¿”å› `true`ï¼Œå› æ­¤æ°¸ä¸æš«åœ

#### `initial_suspend` å‡½æ•¸

æ§åˆ¶å”ç¨‹é–‹å§‹æ™‚çš„è¡Œç‚ºï¼š

**æƒ°æ€§å”ç¨‹ï¼ˆLazy Coroutineï¼‰** - ç«‹å³æš«åœ

```cpp
std::suspend_always initial_suspend() { return std::suspend_always{}; }
```

**æ€¥åˆ‡å”ç¨‹ï¼ˆEager Coroutineï¼‰** - ç«‹å³åŸ·è¡Œ

```cpp
std::suspend_never initial_suspend() { return std::suspend_never{}; }
```

#### `final_suspend` å‡½æ•¸

æ§åˆ¶å”ç¨‹çµæŸæ™‚çš„è¡Œç‚ºï¼š

**æƒ°æ€§å”ç¨‹** - æœ€çµ‚æš«åœ

```cpp
std::suspend_always final_suspend() { return std::suspend_always{}; }
```

**æ€¥åˆ‡å”ç¨‹** - ä¸æš«åœ

```cpp
std::suspend_never final_suspend() { return std::suspend_never{}; }
```

> ğŸ’¡ `initial_suspend` å’Œ `final_suspend` åœ¨å”ç¨‹åŸ·è¡Œæ™‚è‡ªå‹•åŸ·è¡Œï¼š
>
> - `initial_suspend` åœ¨é–‹å§‹æ™‚åŸ·è¡Œ
> - `final_suspend` åœ¨çµæŸæ™‚åŸ·è¡Œ

### Awaiters

**å–å¾— Awaiter çš„å…©ç¨®æ–¹å¼ï¼š**

1. å®šç¾© `co_await` é‹ç®—å­
2. Awaitable ç›´æ¥æˆç‚º Awaiter

**ç·¨è­¯å™¨æŸ¥æ‰¾ Awaiter çš„è¦å‰‡ï¼š**

ç•¶ `co_await expression` è¢«å‘¼å«æ™‚ï¼ˆexpression æ˜¯ awaitableï¼‰ï¼š

1. **æŸ¥æ‰¾ promise ç‰©ä»¶ä¸Šçš„ `co_await` é‹ç®—å­**

   ```cpp
   awaiter = awaitable.operator co_await();
   ```

2. **æŸ¥æ‰¾ç¨ç«‹çš„ `co_await` é‹ç®—å­**

   ```cpp
   awaiter = operator co_await(awaitable);
   ```

3. **è‹¥ç„¡ `co_await` é‹ç®—å­ï¼ŒAwaitable ç›´æ¥æˆç‚º Awaiter**

   ```cpp
   awaiter = awaitable;
   ```

> ğŸ”‘ **æœ€å¸¸è¦‹çš„æƒ…æ³ï¼š`awaiter = awaitable`**
>
> - å¤§å¤šæ•¸å”ç¨‹å¯¦ä½œä¸­ï¼ŒAwaitable éš±å¼æˆç‚º Awaiter
> - åƒ…åœ¨ç‰¹æ®Šæƒ…æ³ï¼ˆå¦‚åŸ·è¡Œç·’åŒæ­¥ï¼‰æ‰ä½¿ç”¨ `co_await` é‹ç®—å­å–å¾— Awaiter

## The Workflow

ç·¨è­¯å™¨è½‰æ›å”ç¨‹ä¸¦åŸ·è¡Œå…©å€‹å·¥ä½œæµç¨‹ï¼š

- **å¤–éƒ¨ Promise å·¥ä½œæµç¨‹ï¼ˆPromise Workflowï¼‰**
- **å…§éƒ¨ Awaiter å·¥ä½œæµç¨‹ï¼ˆAwaiter Workflowï¼‰**

### Promise å·¥ä½œæµç¨‹

#### ç·¨è­¯å™¨è½‰æ›

ç•¶å‡½æ•¸ä¸­ä½¿ç”¨ `co_yield`ã€`co_await` æˆ– `co_return` æ™‚ï¼Œç·¨è­¯å™¨å°‡å‡½æ•¸æœ¬é«”è½‰æ›ç‚º Promise ç‰©ä»¶ï¼š

```cpp
{
  Promise prom;
  co_await prom.initial_suspend();
  try {
    /* <function body having co_return, co_yield, or co_wait> */
  } catch (...) {
    prom.unhandled_exception();
  }

FinalSuspend:
  co_await prom.final_suspend();
}
```

#### åŸ·è¡Œæ­¥é©Ÿ

1. å”ç¨‹é–‹å§‹åŸ·è¡Œ
   - å¿…è¦æ™‚åˆ†é…å”ç¨‹å¹€
   - è¤‡è£½æ‰€æœ‰å‡½æ•¸åƒæ•¸åˆ°å”ç¨‹å¹€
   - å‰µå»º promise ç‰©ä»¶ `prom`
   - å‘¼å« `prom.get_return_object()` å‰µå»ºå”ç¨‹æ§åˆ¶æŸ„ï¼Œå­˜æ–¼å±€éƒ¨è®Šæ•¸
     - ç•¶å”ç¨‹é¦–æ¬¡æš«åœæ™‚ï¼Œæ­¤çµæœæœƒè¿”å›çµ¦å‘¼å«è€…
   - å‘¼å« `prom.initial_suspend()` ä¸¦ `co_await` å…¶çµæœ
     - æ€¥åˆ‡å”ç¨‹ï¼ˆEagerly-startedï¼‰ï¼šè¿”å› `suspend_never`
     - æƒ°æ€§å”ç¨‹ï¼ˆLazily-startedï¼‰ï¼šè¿”å› `suspend_always`
   - ç•¶ `co_await prom.initial_suspend()` æ¢å¾©æ™‚ï¼ŒåŸ·è¡Œå”ç¨‹æœ¬é«”
2. å”ç¨‹åˆ°é”æš«åœé»
   - è¿”å›ç‰©ä»¶ï¼ˆ`prom.get_return_object()`ï¼‰è¿”å›çµ¦å‘¼å«è€…
   - å‘¼å«è€…å¯æ¢å¾©å”ç¨‹
3. å”ç¨‹åˆ°é” `co_return`
   - `co_return` æˆ– `co_return expression`ï¼ˆexpression ç‚º voidï¼‰
     - å‘¼å« `prom.return_void()`
   - `co_return expression`ï¼ˆexpression ç‚ºé void å‹åˆ¥ï¼‰
     - å‘¼å« `prom.return_value(expression)`
   - éŠ·æ¯€æ‰€æœ‰å †ç–Šå‰µå»ºçš„è®Šæ•¸
   - å‘¼å« `prom.final_suspend()` ä¸¦ `co_await` å…¶çµæœ
4. å”ç¨‹è¢«éŠ·æ¯€
   - éŠ·æ¯€æ™‚æ©Ÿï¼š
     - é€é `co_return` çµ‚æ­¢
     - æœªæ•ç²çš„ä¾‹å¤–
     - é€éå”ç¨‹æ§åˆ¶æŸ„
   - éŠ·æ¯€æ­¥é©Ÿï¼š
     - å‘¼å« promise ç‰©ä»¶çš„è§£æ§‹å‡½æ•¸
     - å‘¼å«å‡½æ•¸åƒæ•¸çš„è§£æ§‹å‡½æ•¸
     - é‡‹æ”¾å”ç¨‹å¹€ä½¿ç”¨çš„è¨˜æ†¶é«”
     - å°‡æ§åˆ¶æ¬Šè½‰ç§»å›å‘¼å«è€…

- ç•¶å”ç¨‹ä»¥æœªæ•ç²çš„ä¾‹å¤–çµæŸæ™‚ï¼š
  1. æ•ç²ä¾‹å¤–ä¸¦å¾ catch å€å¡Šå‘¼å« `prom.unhandled_exception()`
  2. å‘¼å« `prom.final_suspend()` ä¸¦ `co_await` å…¶çµæœ

### Awaiter å·¥ä½œæµç¨‹

#### è§¸ç™¼æ™‚æ©Ÿ

ç•¶ä½¿ç”¨ä»¥ä¸‹ä»»ä¸€æ™‚ï¼Œå•Ÿå‹•å…§éƒ¨ awaiter å·¥ä½œæµç¨‹ï¼š

- `co_await expr`
- ç·¨è­¯å™¨éš±å¼å‘¼å«ï¼š
  - `co_await prom.initial_suspend()`
  - `co_await prom.final_suspend()`
  - `co_await prom.yield_value(value)`

#### ç·¨è­¯å™¨ç”Ÿæˆçš„ç¨‹å¼ç¢¼

ç·¨è­¯å™¨åŸºæ–¼ `await_ready`ã€`await_suspend`ã€`await_resume` å‡½æ•¸è½‰æ›ç¨‹å¼ç¢¼ï¼š

```cpp
// ç·¨è­¯å™¨ç”Ÿæˆçš„ co_await å±•é–‹é‚è¼¯ (pseudo code)
auto &&awaitable = /* expression */;

if (!awaitable.await_ready()) {
  // ä¿å­˜ç•¶å‰åŸ·è¡Œç‹€æ…‹ï¼Œå”ç¨‹æº–å‚™æš«åœ

  // æ ¹æ“š await_suspend çš„è¿”å›é¡å‹ï¼Œæœ‰ä¸‰ç¨®æƒ…æ³ï¼š
  // æƒ…æ³ 1: await_suspend è¿”å› void
  if constexpr (std::is_void_v<decltype(awaitable.await_suspend(handle))>) {
    awaitable.await_suspend(handle);
    // å”ç¨‹æš«åœï¼Œæ§åˆ¶æ¬Šè¿”å›çµ¦èª¿ç”¨è€…
    // ç¨å¾Œç•¶å…¶ä»–ä»£ç¢¼å‘¼å« handle.resume() æ™‚ï¼Œæœƒå¾é€™è£¡ç¹¼çºŒ
  }

  // æƒ…æ³ 2: await_suspend è¿”å› bool
  else if constexpr (std::is_same_v<bool, decltype(awaitable.await_suspend(handle))>) {
    bool should_suspend = awaitable.await_suspend(handle);

    if (should_suspend) {
      // true: å”ç¨‹æš«åœï¼Œæ§åˆ¶æ¬Šè¿”å›çµ¦èª¿ç”¨è€…
      // ç¨å¾Œç•¶å…¶ä»–ä»£ç¢¼å‘¼å« handle.resume() æ™‚ï¼Œæœƒå¾é€™è£¡ç¹¼çºŒ
    }
    // false: ä¸æš«åœï¼Œç›´æ¥å¾€ä¸‹åŸ·è¡Œåˆ° resumption_point
  }

  // æƒ…æ³ 3: await_suspend è¿”å›å¦ä¸€å€‹ coroutine_handle
  else {
    auto next_handle = awaitable.await_suspend(handle);

    // ç•¶å‰å”ç¨‹æš«åœï¼Œä½†ç«‹å³åˆ‡æ›åŸ·è¡Œå¦ä¸€å€‹å”ç¨‹
    next_handle.resume();
    // æ§åˆ¶æ¬Šè½‰ç§»åˆ° next_handleï¼Œç•¶å‰å”ç¨‹å·²æš«åœ
    // ç¨å¾Œç•¶å…¶ä»–ä»£ç¢¼èª¿ç”¨ handle.resume() æ™‚ï¼Œæœƒå¾é€™è£¡ç¹¼çºŒ
  }
}

// resumption_point: å”ç¨‹æ¢å¾©æˆ–ç¹¼çºŒåŸ·è¡Œçš„ä½ç½®
// è¿”å› await_resume() çš„çµæœï¼Œä½œç‚ºæ•´å€‹ co_await è¡¨é”å¼çš„å€¼
return awaitable.await_resume();
```

#### åŸ·è¡Œé‚è¼¯

**æƒ…æ³ 1ï¼š`await_ready()` è¿”å› `true`**

- å”ç¨‹å°±ç·’
- ç›´æ¥è¿”å› `awaitable.await_resume()` çš„çµæœ
- ä¸åŸ·è¡Œæš«åœæµç¨‹

**æƒ…æ³ 2ï¼š`await_ready()` è¿”å› `false`**

1. æš«åœå”ç¨‹
2. è©•ä¼° `awaitable.await_suspend()` çš„è¿”å›å€¼

**`await_suspend()` è¿”å›å‹åˆ¥èˆ‡è¡Œç‚ºï¼š**

| è¿”å›å‹åˆ¥                 | è¡Œç‚º                         |
| ------------------------ | ---------------------------- |
| `void`                   | å”ç¨‹ä¿æŒæš«åœï¼Œè¿”å›çµ¦å‘¼å«è€…   |
| `bool` == `true`         | å”ç¨‹ä¿æŒæš«åœï¼Œè¿”å›çµ¦å‘¼å«è€…   |
| `bool` == `false`        | å”ç¨‹æ¢å¾©åŸ·è¡Œï¼Œä¸è¿”å›çµ¦å‘¼å«è€… |
| `anotherCoroutineHandle` | æ¢å¾©å¦ä¸€å€‹å”ç¨‹ä¸¦è¿”å›çµ¦å‘¼å«è€… |

- ä¾‹å¤–è™•ç†ï¼š ç™¼ç”Ÿä½ç½®ä¸åŒï¼Œè™•ç†æ–¹å¼ä¸åŒ

  | ç™¼ç”Ÿä½ç½®        | è™•ç†æ–¹å¼                                                    |
  | --------------- | ----------------------------------------------------------- |
  | `await_ready`   | å”ç¨‹ä¸æš«åœï¼Œ`await_suspend` å’Œ `await_resume` ä¸è¢«å‘¼å«      |
  | `await_suspend` | ä¾‹å¤–è¢«æ•ç²ï¼Œå”ç¨‹æ¢å¾©ï¼Œä¾‹å¤–é‡æ–°æ‹‹å‡ºï¼Œ`await_resume` ä¸è¢«å‘¼å« |
  | `await_resume`  | `await_ready` å’Œ `await_suspend` å·²è©•ä¼°ï¼Œä½†ä¸è¿”å›çµæœ       |

> ğŸ’¡ **å·¥ä½œæµç¨‹é—œä¿‚**
>
> - Promise å·¥ä½œæµç¨‹æ˜¯å¤–éƒ¨æµç¨‹ï¼Œæ§åˆ¶å”ç¨‹çš„æ•´é«”ç”Ÿå‘½é€±æœŸ
> - Awaiter å·¥ä½œæµç¨‹æ˜¯å…§éƒ¨æµç¨‹ï¼Œæ¯æ¬¡ `co_await` æ™‚åŸ·è¡Œ
> - å…©å€‹å·¥ä½œæµç¨‹å”åŒé‹ä½œï¼Œå¯¦ç¾å”ç¨‹çš„æš«åœå’Œæ¢å¾©æ©Ÿåˆ¶

## The `co_return` Keyword

- **`co_return`** æ˜¯å”ç¨‹çš„è¿”å›èªå¥
- å”ç¨‹ä½¿ç”¨ `co_return` å–ä»£æ™®é€šå‡½æ•¸çš„ `return`

### Future ç¯„ä¾‹

å¯¦ç¾ä¸€å€‹æœ€ç°¡å–®ä½†æœ‰æ„ç¾©çš„å”ç¨‹ï¼šè‡ªå‹•å„²å­˜èª¿ç”¨çµæœçš„ Futureã€‚

```cpp
#include <coroutine>
#include <iostream>
#include <memory>

template <typename T>
struct MyFuture {
  std::shared_ptr<T> value;
  MyFuture(std::shared_ptr<T> p) : value(p) {}
  ~MyFuture() {}
  T get() { return *value; }

  struct promise_type {
    std::shared_ptr<T> ptr = std::make_shared<T>();
    ~promise_type() {}
    MyFuture<T> get_return_object() { return ptr; }
    void return_value(T v) { *ptr = v; }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    void unhandled_exception() { std::exit(1); }
  };
};

MyFuture<int> createFuture() { co_return 42; }

int main() {
  auto fut = createFuture();
  std::cout << "fut.get(): " << fut.get() << '\n';
}
```

### åŸ·è¡Œæµç¨‹èªªæ˜

**MyFuture çš„è¡Œç‚ºç‰¹æ€§ï¼š**

- é¡ä¼¼ futureï¼Œä½†ç«‹å³åŸ·è¡Œ
- `createFuture()` è¢«èª¿ç”¨æ™‚è¿”å› future ç‰©ä»¶
- `fut.get()` å–å¾—é—œè¯ promise çš„çµæœ

**é—œéµå¯¦ä½œç´°ç¯€ï¼š**

- **ç”Ÿå‘½é€±æœŸç®¡ç†**
  - è¿”å›å€¼åœ¨å”ç¨‹åŸ·è¡Œå®Œæˆå¾Œæ‰å¯ç”¨
  - ä½¿ç”¨ `std::shared_ptr` ç®¡ç†è¿”å›å€¼ï¼ˆé¿å…ç”Ÿå‘½é€±æœŸå•é¡Œï¼‰
- **åŸ·è¡Œæ™‚æ©Ÿ**
  - ä½¿ç”¨ `std::suspend_never`ï¼Œå”ç¨‹æ°¸ä¸æš«åœ
  - èª¿ç”¨ `createFuture()` æ™‚ç«‹å³åŸ·è¡Œå”ç¨‹
- **Promise å·¥ä½œæµç¨‹**
  - `get_return_object()` å‰µå»ºä¸¦å„²å­˜ promise ç‰©ä»¶çš„æ§åˆ¶æŸ„
  - `return_value()` å„²å­˜ `co_return 2021` æä¾›çš„çµæœ
  - å®¢æˆ¶ç«¯èª¿ç”¨ `fut.get()` å–å¾—çµæœ

**å¯¦ç”¨æ€§æ€è€ƒï¼š**

- é€™å€‹å”ç¨‹è¡¨é¢ä¸Šçœ‹èµ·ä¾†åƒæ™®é€šå‡½æ•¸ï¼Œä¼¼ä¹ä¸å€¼å¾—å¦‚æ­¤è¤‡é›œçš„å¯¦ä½œ
- ä½†å®ƒæ˜¯å¯¦ä½œå„ç¨® future è®Šé«”çš„ç†æƒ³èµ·é»
- å¯ä½œç‚ºæ›´è¤‡é›œç•°æ­¥æ“ä½œçš„åŸºç¤æ¡†æ¶

## The `co_yield` Keyword

- **`co_yield`** ç”¨æ–¼å¯¦ç¾ç”Ÿæˆå™¨ï¼ˆGeneratorï¼‰ï¼Œç”¢ç”Ÿç„¡é™è³‡æ–™æµ
- å¯ä»¥æŒ‰éœ€é€ä¸€æŸ¥è©¢å€¼

**å…§éƒ¨æ©Ÿåˆ¶ï¼š**

- Generator å…§éƒ¨æŒæœ‰ç‰¹æ®Šçš„ promise `p`
- `co_yield i` ç­‰åƒ¹æ–¼ `co_await p.yield_value(i)`
- å¯ä»»æ„æ¬¡æ•¸å‘¼å« `co_yield`
- æ¯æ¬¡å‘¼å«å¾Œï¼Œå”ç¨‹åŸ·è¡Œç«‹å³æš«åœ

### ç„¡é™è³‡æ–™æµç¯„ä¾‹

å¯¦ç¾ä¸€å€‹å¾èµ·å§‹å€¼é–‹å§‹ã€æŒ‰æ­¥é•·éå¢çš„ç„¡é™è³‡æ–™æµç”Ÿæˆå™¨ã€‚

```cpp
#include <coroutine>
#include <iostream>
#include <memory>

template <typename T>
struct Generator {
  struct promise_type;
  using handle_type = std::coroutine_handle<promise_type>;

  Generator(handle_type h) : coro(h) {}
  handle_type coro;

  ~Generator() {
    if (coro) coro.destroy();
  }
  Generator(const Generator &) = delete;
  Generator &operator=(const Generator &) = delete;
  Generator(Generator &&oth) noexcept : coro(oth.coro) { oth.coro = nullptr; }
  Generator &operator=(Generator &&oth) noexcept {
    coro = oth.coro;
    oth.coro = nullptr;
    return *this;
  }

  T getValue() { return coro.promise().current_value; }

  bool next() {
    coro.resume();
    return not coro.done();
  }

  struct promise_type {
    promise_type() = default;
    ~promise_type() = default;

    auto initial_suspend() { return std::suspend_always{}; }
    auto final_suspend() noexcept { return std::suspend_always{}; }
    auto get_return_object() { return Generator{handle_type::from_promise(*this)}; }
    auto return_void() { return std::suspend_never{}; }

    auto yield_value(const T value) {
      current_value = value;
      return std::suspend_always{};
    }
    void unhandled_exception() { std::exit(1); }
    T current_value;
  };
};

Generator<int> getNext(int start = 0, int step = 1) {
  auto value = start;
  while (true) {
    co_yield value;
    value += step;
  }
}

int main() {
  std::cout << "getNext():";
  auto gen = getNext();
  for (int i = 0; i <= 10; ++i) {
    gen.next();
    std::cout << " " << gen.getValue();
  }

  std::cout << "\n\ngetNext(100, -10):";
  auto gen2 = getNext(100, -10);
  for (int i = 0; i <= 20; ++i) {
    gen2.next();
    std::cout << " " << gen2.getValue();
  }
  std::cout << '\n';
}
```

**è¼¸å‡ºï¼š**

- `gen`ï¼šå¾ 0 åˆ° 10ï¼ˆéå¢ 1ï¼‰
- `gen2`ï¼šå¾ 100 åˆ° -10ï¼ˆéæ¸› 10ï¼‰

### åŸ·è¡Œæµç¨‹

**é¦–æ¬¡è¿­ä»£çš„æ­¥é©Ÿï¼š**

1. å‰µå»º promise ç‰©ä»¶
2. å‘¼å« `promise.get_return_object()` ä¸¦å°‡çµæœä¿å­˜åœ¨å±€éƒ¨è®Šæ•¸
3. å‰µå»º generator ç‰©ä»¶
4. å‘¼å« `promise.initial_suspend()`
   - Generator æ˜¯æƒ°æ€§çš„ï¼ˆlazyï¼‰ï¼Œç¸½æ˜¯æš«åœ
5. è«‹æ±‚ä¸‹ä¸€å€‹å€¼ï¼Œä¸¦æª¢æŸ¥ generator æ˜¯å¦å·²è€—ç›¡
6. ç”± `co_yield` è§¸ç™¼ï¼Œå€¼åœ¨æ­¤å¾Œå¯ç”¨
7. å–å¾—ä¸‹ä¸€å€‹å€¼

**å¾ŒçºŒè¿­ä»£ï¼š**

- åƒ…åŸ·è¡Œæ­¥é©Ÿ 5ã€6ã€7

> ğŸ’¡ **Generator çš„ç‰¹æ€§**
>
> - æƒ°æ€§æ±‚å€¼ï¼šåªåœ¨éœ€è¦æ™‚æ‰ç”¢ç”Ÿå€¼
> - è¨˜æ†¶é«”æ•ˆç‡ï¼šä¸éœ€é å…ˆç”Ÿæˆæ‰€æœ‰å€¼
> - ç„¡é™è³‡æ–™æµï¼šå¯å®‰å…¨åœ°å»ºæ¨¡ç„¡é™åºåˆ—

## The `co_await` Keyword

- **`co_await`** ç”¨æ–¼æš«åœæˆ–æ¢å¾©å”ç¨‹çš„åŸ·è¡Œ
- `co_await exp` ä¸­çš„è¡¨é”å¼ `exp` å¿…é ˆæ˜¯ **awaitable è¡¨é”å¼**
  - éœ€å¯¦ä½œä¸‰å€‹å‡½æ•¸ï¼š`await_ready`ã€`await_suspend`ã€`await_resume`

### å…¸å‹æ‡‰ç”¨ï¼šäº‹ä»¶é©…å‹•ä¼ºæœå™¨

**å‚³çµ±é˜»å¡å¼ä¼ºæœå™¨ï¼š**

```cpp
Acceptor acceptor{443};
while (true) {
  Socket socket = acceptor.accept();  // é˜»å¡
  auto request = socket.read();       // é˜»å¡
  auto response = handleRequest(request);
  socket.write(response);  // é˜»å¡
}
```

- åœ¨å–®ä¸€åŸ·è¡Œç·’ä¸­ä¾åºè™•ç†æ¯å€‹è«‹æ±‚
- `accept()`ã€`read()`ã€`write()` éƒ½æ˜¯é˜»å¡å‘¼å«

**ä½¿ç”¨ co_await æ”¹é€²ï¼š**

```cpp
Acceptor acceptor{443};
while (true) {
  Socket socket = co_await acceptor.accept();
  auto request = co_await socket.read();
  auto response = handleRequest(request);
  co_await socket.write(response);
}
```

- é˜»å¡å‘¼å«è®Šç‚ºå¯æš«åœå’Œæ¢å¾©
- è³‡æºå‹å¥½çš„ç­‰å¾…å–ä»£è³‡æºæ¶ˆè€—çš„é˜»å¡

### æŒ‰éœ€å•Ÿå‹•ä»»å‹™

æœ€ç°¡å–®çš„ `co_await` ç¯„ä¾‹ï¼šä½¿ç”¨é å®šç¾©çš„ `std::suspend_never()`ã€‚

```cpp
#include <coroutine>
#include <iostream>

struct Job {
  struct promise_type;
  using handle_type = std::coroutine_handle<promise_type>;
  handle_type coro;
  Job(handle_type h) : coro(h) {}
  ~Job() {
    if (coro) coro.destroy();
  }
  void start() { coro.resume(); }

  struct promise_type {
    auto get_return_object() { return Job{handle_type::from_promise(*this)}; }
    std::suspend_always initial_suspend() {
      std::cout << " Preparing job\n";
      return {};
    }
    std::suspend_always final_suspend() noexcept {
      std::cout << "  Performing job\n";
      return {};
    }
    void unhandled_exception() {}
  };
};

Job prepareJob() { co_await std::suspend_never(); }

int main() {
  std::cout << "Before job\n";

  auto job = prepareJob();
  job.start();

  std::cout << "After job\n";
}
```

**åŸ·è¡Œæµç¨‹ï¼š**

1. `prepareJob()` å‰µå»ºå”ç¨‹ç‰©ä»¶ï¼ˆå”ç¨‹å·¥å» ï¼‰
2. `initial_suspend()` è¿”å› `std::suspend_always`ï¼Œå”ç¨‹ç«‹å³æš«åœ
3. `job.start()` èª¿ç”¨ `coro.resume()` æ¢å¾©å”ç¨‹
4. `final_suspend()` è¿”å› `std::suspend_always`ï¼Œå”ç¨‹å†æ¬¡æš«åœ
   - é€™ä½¿å¾—ä¸éœ€è¦åœ¨ `promise_type` ä¸­å¯¦ä½œ `return_void()`

> ğŸ’¡ **é—œéµç†è§£**
>
> - `prepareJob()` é›–ç„¶ä½¿ç”¨ `co_await std::suspend_never()`ï¼Œä½†ä»ç„¶æ˜¯å”ç¨‹å·¥å» 
> - å”ç¨‹ç‰©ä»¶åœ¨å‰µå»ºæ™‚å°±å›  `initial_suspend()` è€Œæš«åœ
> - å¿…é ˆé¡¯å¼èª¿ç”¨ `start()` æ‰èƒ½æ¢å¾©åŸ·è¡Œ

### åŸ·è¡Œç·’åŒæ­¥

ä½¿ç”¨å”ç¨‹å¯¦ç¾åŸ·è¡Œç·’åŒæ­¥ï¼Œé¿å…æ¢ä»¶è®Šæ•¸çš„é¢¨éšªï¼ˆå¦‚è™›å‡å–šé†’å’Œä¸Ÿå¤±å–šé†’ï¼‰ã€‚

#### å®Œæ•´ç¯„ä¾‹

```cpp
#include <atomic>
#include <chrono>
#include <coroutine>
#include <functional>
#include <iostream>
#include <stdexcept>
#include <string>
#include <thread>

class Event {
 public:
  Event() = default;

  Event(const Event &) = delete;
  Event(Event &&) = delete;
  Event &operator=(const Event &) = delete;
  Event &operator=(Event &&) = delete;

  class Awaiter;
  Awaiter operator co_await() const noexcept;

  void notify() noexcept;

 private:
  friend class Awaiter;

  mutable std::atomic<void *> suspendedWaiter{nullptr};
  mutable std::atomic<bool> notified{false};
};

class Event::Awaiter {
 public:
  Awaiter(const Event &eve) : event(eve) {}

  bool await_ready() const;
  bool await_suspend(std::coroutine_handle<> corHandle) noexcept;
  void await_resume() noexcept {}

 private:
  friend class Event;
  const Event &event;
  std::coroutine_handle<> coroutineHandle;
};

bool Event::Awaiter::await_ready() const {
  // æœ€å¤šåªå…è¨±ä¸€å€‹ç­‰å¾…è€…
  if (event.suspendedWaiter.load() != nullptr) {
    throw std::runtime_error("More than one waiter is not valid");
  }
  // event.notified == false: æš«åœå”ç¨‹
  // event.notified == true: å”ç¨‹åƒæ™®é€šå‡½æ•¸ä¸€æ¨£åŸ·è¡Œ
  return event.notified;
}

bool Event::Awaiter::await_suspend(std::coroutine_handle<> corHandle) noexcept {
  coroutineHandle = corHandle;
  if (event.notified) return false;
  // å„²å­˜ç­‰å¾…è€…ä»¥ä¾¿ç¨å¾Œé€šçŸ¥
  event.suspendedWaiter.store(this);
  return true;
}

void Event::notify() noexcept {
  notified = true;

  // å˜—è©¦è¼‰å…¥ç­‰å¾…è€…
  auto *waiter = static_cast<Awaiter *>(suspendedWaiter.load());

  // æª¢æŸ¥æ˜¯å¦æœ‰ç­‰å¾…è€…
  if (waiter != nullptr) {
    // æ¢å¾©å”ç¨‹ => await_resume
    waiter->coroutineHandle.resume();
  }
}

Event::Awaiter Event::operator co_await() const noexcept { return Awaiter{*this}; }

struct Task {
  struct promise_type {
    Task get_return_object() { return {}; }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    void return_void() {}
    void unhandled_exception() {}
  };
};

Task receiver(Event &event) {
  auto start = std::chrono::high_resolution_clock::now();
  co_await event;
  std::cout << "Got the notification!\n";
  auto end = std::chrono::high_resolution_clock::now();
  std::chrono::duration<double> elapsed = end - start;
  std::cout << "Waited " << elapsed.count() << " seconds.\n";
}

using namespace std::chrono_literals;

int main() {
  std::cout << "Notification before waiting\n";
  Event event1{};
  auto senderThread1 = std::thread([&event1] { event1.notify(); });
  auto receiverThread1 = std::thread(receiver, std::ref(event1));

  receiverThread1.join();
  senderThread1.join();

  std::cout << "\nNotification after 2 seconds waiting\n";
  Event event2{};
  auto receiverThread2 = std::thread(receiver, std::ref(event2));
  auto senderThread2 = std::thread([&event2] {
    std::this_thread::sleep_for(2s);
    event2.notify();
  });

  receiverThread2.join();
  senderThread2.join();
}
```

#### ä½¿ç”¨è€…è¦–è§’

- `senderThread1` å’Œ `senderThread2` é€é `event.notify()` ç™¼é€é€šçŸ¥
- å”ç¨‹ `receiver` åœ¨ `receiverThread1` å’Œ `receiverThread2` ä¸­åŸ·è¡Œ
- æ¸¬é‡å”ç¨‹å¾é–‹å§‹åˆ°çµæŸçš„æ™‚é–“ï¼Œé¡¯ç¤ºç­‰å¾…æ™‚é•·

**èˆ‡ Generator çš„å·®ç•°ï¼š**

- Generatorï¼šAwaitable åŒæ™‚æ˜¯ Awaiter
- Eventï¼šä½¿ç”¨ `operator co_await` è¿”å› Awaiter
- è·è²¬åˆ†é›¢æ”¹å–„äº†ç¨‹å¼ç¢¼çµæ§‹

#### å¯¦ä½œè€…è¦–è§’ï¼šå·¥ä½œæµç¨‹

**é—œéµæˆå“¡ï¼š**

- `suspendedWaiter`ï¼šå„²å­˜ç­‰å¾…è€…
- `notified`ï¼šé€šçŸ¥ç‹€æ…‹

å·¥ä½œæµç¨‹ 1ï¼šé€šçŸ¥åœ¨ç­‰å¾…ä¹‹å‰

1. `event1.notify()` è¢«èª¿ç”¨
   - è¨­ç½® `notified = true`
   - è¼‰å…¥ `suspendedWaiter`ï¼ˆæ­¤æ™‚ç‚º `nullptr`ï¼‰
   - ä¸åŸ·è¡Œ `resume()`
2. `co_await event1` è§¸ç™¼ `await_ready()`
   - æª¢æŸ¥æ˜¯å¦è¶…éä¸€å€‹ç­‰å¾…è€…
   - è¿”å› `event.notified`ï¼ˆç‚º `true`ï¼‰
   - å”ç¨‹**ä¸æš«åœ**ï¼Œåƒæ™®é€šå‡½æ•¸ä¸€æ¨£åŸ·è¡Œ

å·¥ä½œæµç¨‹ 2ï¼šé€šçŸ¥åœ¨ç­‰å¾…ä¹‹å¾Œ

1. `co_await event2` è§¸ç™¼ `await_ready()`
   - `event.notified` ç‚º `false`
   - å”ç¨‹éœ€è¦æš«åœ
2. `await_suspend(corHandle)` è¢«åŸ·è¡Œ
   - å„²å­˜ `coroutineHandle` ä»¥ä¾¿ç¨å¾Œæ¢å¾©
   - å°‡ `this` å„²å­˜åˆ° `suspendedWaiter`
   - è¿”å› `true`ï¼ˆæš«åœå”ç¨‹ï¼‰
3. ç¨å¾Œ `event2.notify()` è¢«èª¿ç”¨
   - è¨­ç½® `notified = true`
   - è¼‰å…¥ `suspendedWaiter`ï¼ˆä¸ç‚º `nullptr`ï¼‰
   - èª¿ç”¨ `waiter->coroutineHandle.resume()` æ¢å¾©å”ç¨‹

> âš ï¸ **è¨­è¨ˆè€ƒé‡**
>
> - åƒ…æ”¯æ´å–®ä¸€ç­‰å¾…è€…ï¼ˆå¤šç­‰å¾…è€…æœƒæ‹‹å‡ºä¾‹å¤–ï¼‰
> - ä½¿ç”¨åŸå­æ“ä½œç¢ºä¿åŸ·è¡Œç·’å®‰å…¨
> - é€šçŸ¥é †åºæ±ºå®šå”ç¨‹æ˜¯å¦æš«åœ

### ç¸½çµ

**å”ç¨‹æ ¸å¿ƒç‰¹æ€§ï¼š**

- å»£ç¾©çš„å‡½æ•¸ï¼Œå¯æš«åœå’Œæ¢å¾©åŸ·è¡ŒåŒæ™‚ä¿æŒç‹€æ…‹
- C++20 æä¾›å¯¦ä½œæ¡†æ¶ï¼ˆè¶…é 20 å€‹å‡½æ•¸ï¼‰ï¼Œè€Œéå…·é«”å”ç¨‹
- é€é `co_await`ã€`co_yield`ã€`co_return` æ“´å±•å‡½æ•¸åŸ·è¡Œæ¦‚å¿µ

**`co_await` çš„å„ªå‹¢ï¼š**

- å°‡è³‡æºæ¶ˆè€—çš„é˜»å¡è½‰æ›ç‚ºè³‡æºå‹å¥½çš„ç­‰å¾…
- `auto getResult = func()` åœ¨çµæœæœªå°±ç·’æ™‚ä¸æœƒé˜»å¡
- æš«åœå’Œæ¢å¾©è¡¨é”å¼çš„åŸ·è¡Œ

**`co_yield` çš„å„ªå‹¢ï¼š**

- å¯¦ç¾ç„¡é™è³‡æ–™æµ
- æŒ‰éœ€ç”¢ç”Ÿå€¼ï¼Œè¨˜æ†¶é«”æ•ˆç‡é«˜
